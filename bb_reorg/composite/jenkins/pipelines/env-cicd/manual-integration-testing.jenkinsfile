common = load "lib/common.groovy"

def label = "int-test-automation-${UUID.randomUUID().toString()}"
def slackChannel = "#jnkns_int_tests"

timestamps {

    podTemplate(name: 'int-test-automation', label: label, yaml: """
kind: Pod
metadata:
  name: microservice-orchestration
spec:
  containers:
  - name: microservice-orchestration
    image: 407733091588.dkr.ecr.us-west-2.amazonaws.com/ego-cicd/microservice-orchestration:1.0.13
    imagePullPolicy: Always
    command:
    - /bin/cat
    tty: true
"""
    ) {
        node(label) {
            try {
                def secrets = [[$class: 'VaultSecret', path: 'cicd/prod-1/aws_keys', secretValues: [
                        [$class: 'VaultSecretValue', envVar: 'AWS_ACCESS_KEY_ID_PROD', vaultKey: 'AWS_ACCESS_KEY_ID'],
                        [$class: 'VaultSecretValue', envVar: 'AWS_SECRET_ACCESS_KEY_PROD', vaultKey: 'AWS_SECRET_ACCESS_KEY']]],
                               [$class: 'VaultSecret', path: 'cicd/aws_keys', secretValues: [
                                       [$class: 'VaultSecretValue', envVar: 'AWS_ACCESS_KEY_ID_INT', vaultKey: 'AWS_ACCESS_KEY_ID'],
                                       [$class: 'VaultSecretValue', envVar: 'AWS_SECRET_ACCESS_INT', vaultKey: 'AWS_SECRET_ACCESS_KEY']]],
                               [$class: 'VaultSecret', path: 'cicd/bitbucket', secretValues: [
                                       [$class: 'VaultSecretValue', envVar: 'BITBUCKET_USER', vaultKey: 'BITBUCKET_USER'],
                                       [$class: 'VaultSecretValue', envVar: 'BITBUCKET_APP_PASSWORD', vaultKey: 'BITBUCKET_APP_PASSWORD']]],
                               [$class: 'VaultSecret', path: 'cicd/artifactory', secretValues: [
                                       [$class: 'VaultSecretValue', envVar: 'ART_TOOL_USER', vaultKey: 'ART_TOOL_USER'],
                                       [$class: 'VaultSecretValue', envVar: 'ART_TOOL_PASSWORD', vaultKey: 'ART_TOOL_PASSWORD'],
                                       [$class: 'VaultSecretValue', envVar: 'ART_BUILD_USER', vaultKey: 'ART_BUILD_USER'],
                                       [$class: 'VaultSecretValue', envVar: 'ART_BUILD_PASSWORD', vaultKey: 'ART_BUILD_PASSWORD']]],
                               [$class: 'VaultSecret', path: 'cicd/integration/user-manager', secretValues: [
                                       [$class: 'VaultSecretValue', envVar: 'GOOGLE_APPLICATION_CREDENTIALS', vaultKey: 'GOOGLE_APPLICATION_CREDENTIALS'],
                                       [$class: 'VaultSecretValue', envVar: 'GOOGLE_API_KEY', vaultKey: 'GOOGLE_API_KEY']]]]

                wrap([$class: 'VaultBuildWrapper', vaultSecrets: secrets]) {
                    properties([
                            parameters([string(defaultValue: '', description: 'Tested microservice name', name: 'APP_NAME', trim: true),
                                        string(defaultValue: '', description: 'Tested microservice version', name: 'APP_VERSION', trim: true),
                                        choice(choices: ['int-1', 'int-2', 'prod-1'], description: 'Against which environment microservice will be tested?', name: 'CLUSTER_NAME')]),
                            disableConcurrentBuilds()
                    ])
                    env.APP_NAME = "${params.APP_NAME}"
                    env.APP_VERSION = "${params.APP_VERSION}"
                    env.STACK_NAME = "env-${params.ENV_NAME}"
                    env.CLUSTER_NAME = "${params.CLUSTER_NAME}"
                    env.JOB_NAME = "${env.JOB_NAME}"
                    env.BUILD_NUMBER = "${env.BUILD_NUMBER}"
                    currentBuild.displayName = "#${env.BUILD_NUMBER} `${env.APP_NAME}-v${env.APP_VERSION}`"

                    stage('Configure aws account and kubectl config') {
                        if (env.APP_NAME == '' || env.APP_VERSION == '') {
                            return
                        } else {
                            container('microservice-orchestration') {
                                sh '''#!/usr/bin/env bash
            set -eox pipefail
            if [[ "$CLUSTER_NAME" == "prod-1" ]]; then
              /toolbox/set-aws-credentials.sh --key-id ${AWS_ACCESS_KEY_ID_PROD} --secret-access-key ${AWS_SECRET_ACCESS_KEY_PROD}
            else
              /toolbox/set-aws-credentials.sh --key-id ${AWS_ACCESS_KEY_ID_INT} --secret-access-key ${AWS_SECRET_ACCESS_INT}
            fi
            ### Check IAM user
            aws sts get-caller-identity --output text
            ### Configure kubectl
            aws eks --region us-west-2 update-kubeconfig --name ${CLUSTER_NAME}
            ### Check kubectl context
            kubectl config current-context
          '''
                            }
                        }
                    }
                    stage('Integration test') {
                        container('microservice-orchestration') {
                            if (env.APP_NAME == 'portal-internal') {
                                echo '"portal-internal" integration test skipped'
                            } else {
                                sh '''#!/usr/bin/env bash
        set -eo pipefail
        function waitport () {
            local COUNTER=0
            local ip=$1
            local port=$2
            until nc -v -z ${ip} ${port}; do
              if [[ "${COUNTER}" -lt 24 ]]; then
                COUNTER=$(( COUNTER + 1))
                echo "Waiting..."
                sleep 5
                continue
              else
                echo "+++++Port ${port} on ${ip}: not ready more than 2 minutes!+++++"
                #break loop
                return 1
              fi
            done
          }
        function check_http_port_forward () {
          local COUNTER=0
          local port=$1
          until curl -XGET http://localhost:${port}/actuator/prometheus; do
            if [[ "${COUNTER}" -lt 24 ]]; then
              COUNTER=$(( COUNTER + 1))
              echo "Waiting /actuator/prometheus on port ${port}..."
              sleep 5
              continue
            else
              echo "+++++Port Forward for ${port} not ready more than 2 minutes!+++++"
              #break loop
              return 1
            fi
          done
        }
        ### Clone microservice repo
        git clone https://${BITBUCKET_USER}:${BITBUCKET_APP_PASSWORD}@bitbucket.org/imvu/${APP_NAME}.git && cd ${APP_NAME}
        ### Switch to new 'git tag'
        git fetch && git fetch --tags && git checkout ${APP_NAME}-v${APP_VERSION}
        ### Add credentials
        echo -e "\nsystemProp.gradle.wrapperUser=${ART_TOOL_USER}\nsystemProp.gradle.wrapperPassword=${ART_TOOL_PASSWORD}\ndevUser=${ART_BUILD_USER}\ndevPassword=${ART_BUILD_PASSWORD}\npublishUser=build\npublishPassword=" >> ./integration/gradle.properties
        ### Additional port-forward for "account-manager" microservice k8s SVC "rest" and "grpc" ports
        echo "++++++++++++++++++++Additional 'account-manager' port forward enabled++++++++++++++++++++"
        pod_name=$(kubectl -n default get pods -l app=account-manager --sort-by=.metadata.creationTimestamp | grep Running |awk {'print $1'}|tail -1)
        kubectl -n default port-forward --pod-running-timeout=2m0s ${pod_name} 9092:8080 &>/dev/null &
        kubectl -n default port-forward --pod-running-timeout=2m0s ${pod_name} 9093:8081 &>/dev/null &
        ### Additional port-forward for "messenger-server" microservice k8s SVC "grpc" port
        echo "++++++++++++++++++++Additional 'messenger-server' port forward enabled++++++++++++++++++++"
        pod_name=$(kubectl -n default get pods -l app=messenger-server --sort-by=.metadata.creationTimestamp | grep Running |awk {'print $1'}|tail -1)
        kubectl -n default port-forward --pod-running-timeout=2m0s ${pod_name} 9094:8081 &>/dev/null &
        ### Start port-forward tested microservice k8s SVC "rest" and "grpc" ports
        echo "++++++++++++++++++++Port forward enabled++++++++++++++++++++"
        pod_name=$(kubectl -n default get pods -l app=${APP_NAME} --sort-by=.metadata.creationTimestamp | grep Running |awk {'print $1'}|tail -1)
        kubectl -n default port-forward --pod-running-timeout=2m0s ${pod_name} 9090:8080 &>/dev/null &
        kubectl -n default port-forward --pod-running-timeout=2m0s ${pod_name} 9091:8081 &>/dev/null &
        # Call waitport function to check forwarded port.
        waitport 127.0.0.1 9090
        # Test forwarded REST port by curl request.
        check_http_port_forward 9090
        echo "++++++++++++++++++++Port forward works!++++++++++++++++++++"
        ### Run integration test
        if [[ "$CLUSTER_NAME" == "prod-1" ]]; then
          cd ./integration && ./gradlew clean build -PtestEnv=prod --info
        else
          cd ./integration && ./gradlew clean build -PtestEnv=${CLUSTER_NAME} --info
        fi
        ### Kill all background (port-forward) jobs 
        jobs -p | xargs kill ||:
      '''
                            }
                        }
                    }
                }
            } catch (e) {
                currentBuild.result = 'FAILURE'
                throw e
            } finally {
                stage('Send notifications') {
                    container('microservice-orchestration') {
                        if (env.APP_NAME == '' || env.APP_VERSION == '') {
                            currentBuild.result = 'ABORTED'
                            common.notifySlack(currentBuild.result)
                            return
                        } else {
                            common.notifySlack(currentBuild.result)
                        }
                        if (currentBuild.result == 'FAILURE') {
                            common.notifySlack(currentBuild.result, slackChannel, '#FF9FA1', "${currentBuild.result}`${env.JOB_NAME}` ${env.BUILD_DISPLAY_NAME}\nRunning '${env.APP_NAME}-v${env.APP_VERSION} failed integration test.'")
                        } else {
                            return
                        }
                    }
                }
            }
        }
    }

} // End timestamps