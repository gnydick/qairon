/* groovylint-disable CompileStatic, CouldBeSwitchStatement, DuplicateStringLiteral, GStringExpressionWithinString, LineLength, MethodReturnTypeRequired, NestedBlockDepth, NoDef, ParameterReassignment, SpaceAfterClosingBrace, SpaceBeforeClosingBrace, VariableTypeRequired */
def notifySlack(String buildStatus = 'STARTED') {

    // Build status of null means success.
    buildStatus = buildStatus ?: 'SUCCESS'
    def icons
    if (buildStatus == 'STARTED') {
        icons = ':biking:'
    } else if (buildStatus == 'SUCCESS') {
        icons = ':pusheen_dancing:'
    } else if (buildStatus == 'ABORTED') {
        icons = ':thinking_face:'
    } else {
        icons = ':twitching:'
    }
    def color
    if (buildStatus == 'STARTED') {
        color = '#D4DADF'
    } else if (buildStatus == 'SUCCESS') {
        color = '#BDFFC3'
    } else if (buildStatus == 'ABORTED') {
        color = '#FFFE89'
    } else {
        color = '#FF9FA1'
    }
    def msg = "${buildStatus}${icons}: `${env.JOB_NAME}` ${env.BUILD_DISPLAY_NAME}:\n<${env.BUILD_URL}console|Watch build console output>"
    slackSend(color: color, message: msg)
}

def label = "perf-1-automation-${UUID.randomUUID().toString()}"

podTemplate(name: 'perf-1-automation', label: label, yaml: """
kind: Pod
metadata:
  name: microservice-orchestration
spec:
  containers:
  - name: microservice-orchestration
    image: 407733091588.dkr.ecr.us-west-2.amazonaws.com/ego-cicd/microservice-orchestration:1.0.14
    imagePullPolicy: Always
    command:
    - /bin/cat
    tty: true
    env:
    - name: AWS_REGION
      value: "us-west-2"
    - name: STACK_NAME
      value: "env-perf-1"
    - name: CLUSTER_NAME
      value: "perf-1"
    - name: SUBDOMAIN
      value: "perf-1.withme.com"
"""
  ) {
node(label) {
  try {
  def secrets = [[$class: 'VaultSecret', path: 'cicd/aws_keys', secretValues: [
                  [$class: 'VaultSecretValue', envVar: 'AWS_ACCESS_KEY_ID', vaultKey: 'AWS_ACCESS_KEY_ID'],
                  [$class: 'VaultSecretValue', envVar: 'AWS_SECRET_ACCESS_KEY', vaultKey: 'AWS_SECRET_ACCESS_KEY']]],
                [$class: 'VaultSecret', path: 'cicd/bitbucket', secretValues: [
                  [$class: 'VaultSecretValue', envVar: 'BITBUCKET_USER', vaultKey: 'BITBUCKET_USER'],
                  [$class: 'VaultSecretValue', envVar: 'BITBUCKET_APP_PASSWORD', vaultKey: 'BITBUCKET_APP_PASSWORD']]],
                [$class: 'VaultSecret', path: 'cicd/datadog', secretValues: [
                  [$class: 'VaultSecretValue', envVar: 'DD_API_KEY', vaultKey: 'API_KEY']]],
                [$class: 'VaultSecret', path: 'cicd/artifactory', secretValues: [
                  [$class: 'VaultSecretValue', envVar: 'ART_TOOL_USER', vaultKey: 'ART_TOOL_USER'],
                  [$class: 'VaultSecretValue', envVar: 'ART_TOOL_PASSWORD', vaultKey: 'ART_TOOL_PASSWORD'],
                  [$class: 'VaultSecretValue', envVar: 'ART_BUILD_USER', vaultKey: 'ART_BUILD_USER'],
                  [$class: 'VaultSecretValue', envVar: 'ART_BUILD_PASSWORD', vaultKey: 'ART_BUILD_PASSWORD']]],
                [$class: 'VaultSecret', path: 'cicd/perf-1/prometheus-stack', secretValues: [
                  [$class: 'VaultSecretValue', envVar: 'GRAF_PASS', vaultKey: 'GRAF_PASS']]],
                [$class: 'VaultSecret', path: 'cicd/perf-1/cleanspeak', secretValues: [
                  [$class: 'VaultSecretValue', envVar: 'CLEANSPEAK_DATABASE_PASSWORD', vaultKey: 'DATABASE_PASSWORD']]]]

  withCredentials([string(credentialsId: 'EGO_VAULT_ROLE_ID', variable: 'EGO_VAULT_ROLE_ID'), string(credentialsId: 'EGO_VAULT_SECRET_ID', variable: 'EGO_VAULT_SECRET_ID')]) {
  echo "${EGO_VAULT_ROLE_ID}"

      wrap([$class: 'VaultBuildWrapper', vaultSecrets: secrets]) {
  properties([
          disableConcurrentBuilds()
      ])
    env.JOB_NAME = "${env.JOB_NAME}"
    env.BUILD_NUMBER = "${env.BUILD_NUMBER}"

    stage('Configure aws account') {
      notifySlack()
      container('microservice-orchestration')  {
      sh '''#!/usr/bin/env bash
        set -eox pipefail
        /toolbox/set-aws-credentials.sh --key-id ${AWS_ACCESS_KEY_ID} --secret-access-key ${AWS_SECRET_ACCESS_KEY}
        ### Check IAM user
        aws sts get-caller-identity --output text
      '''
    }}
    stage('Environment initiation') {
      container('microservice-orchestration')  {
      sh '''#!/usr/bin/env bash
        set -eo pipefail
        ### Clone repo
        git clone https://${BITBUCKET_USER}:${BITBUCKET_APP_PASSWORD}@bitbucket.org/imvu/${STACK_NAME}.git && cd ${STACK_NAME}/aws

        ### Create environment
        sceptre launch ${AWS_REGION} -y

        ### Configure kubectl
        aws eks --region us-west-2 update-kubeconfig --name ${CLUSTER_NAME}

        ### Check EKS k8s service readiness
        COUNTER=0
        while [[ "${COUNTER}" -lt 30 ]]; do
        EKS_READINESS=$(kubectl get svc -n default | grep 'kubernetes')
            if [[ -z "${EKS_READINESS}" ]]; then
              echo "+++++ EKS masters not ready! +++++"
              COUNTER=$(( COUNTER + 1))
              sleep 10s
              continue
            else
              break
            fi
        done
        if [[ -z "${EKS_READINESS}" ]]; then
          echo  "+++++ EKS masters is not ready more than five minutes! +++++"
          exit 1
        else
          echo  "+++++ EKS masters ready for join worker nodes! +++++"
        fi

        echo "The nodes started.  Waiting for all ${NODE_COUNT} to be ready to receive a deployment."
        NODE_COUNT=$(kubectl get nodes | grep -c 'compute.internal' ||:)
        READY_COUNT=$(kubectl get nodes | grep -c 'Ready')
        COUNTER=0
        while [[ "${READY_COUNT}" != "${NODE_COUNT}" ]]; do
          READY_COUNT=$(kubectl get nodes | grep -c 'Ready')
          echo -n "${READY_COUNT}"
          sleep 20s
          COUNTER=$(( COUNTER + 1))
          if [[ "${COUNTER}" -eq '30' ]]; then
            echo "+++++ Workers is not ready more than ten minutes! +++++"
            exit 1
          fi
        done
        echo "All nodes started and ready for work!"
      '''
    }}
    stage('Configure Helm & Deploy DataDog') {
      container('microservice-orchestration')  {
      sh '''#!/usr/bin/env bash
        set -eo pipefail
        ### Create namespaces and Helm install
        kubectl apply -f ${WORKSPACE}/${STACK_NAME}/k8s/namespaces.yaml
        # Configure helm repos
        helm repo add ego-helm-release https://withme.jfrog.io/withme/ego-helm-release/ --username $ART_BUILD_USER --password $ART_BUILD_PASSWORD && helm repo update
        helm repo add stable https://charts.helm.sh/stable && helm repo update
        ### Check chart versions
        helm search repo -l ego-
        ### Deploy datadog
        helm upgrade datadog-agent ego-helm-release/datadog -f ${WORKSPACE}/${STACK_NAME}/k8s/monitoring-tier/datadog-agent-values.yaml -n datadog --install --set datadog.site='datadoghq.com' --set datadog.apiKey=${DD_API_KEY}
      '''
    }}
    stage('Deploy Redis') {
      container('microservice-orchestration')  {
      sh '''#!/usr/bin/env bash
        set -eo pipefail
        ### Create namespace and Helm install
        helm upgrade redis ego-helm-release/redis -f ${WORKSPACE}/${STACK_NAME}/k8s/database-tier/redis/redis-values.yaml --install --timeout 600s -n database
      '''
    }}
    stage('Deploy Service-Gateway') {
      container('microservice-orchestration')  {
      sh '''#!/usr/bin/env bash
        set -eo pipefail
        ### Deploy Service-Gateway
        helm upgrade service-gateway ego-helm-release/ego-microservice -f ${WORKSPACE}/${STACK_NAME}/k8s/service-gateway-tier/service-gateway-values.yaml -n default --install --wait --timeout 300s
      '''
    }}
    stage('Deploy Istio') {
      container('microservice-orchestration')  {
      sh '''#!/usr/bin/env bash
        set -eo pipefail
        ### Deploy Istio Init
        helm upgrade istio-init ego-helm-release/istio-init -f ${WORKSPACE}/${STACK_NAME}/k8s/util-tier/istio/istio-init-values.yaml -n istio-system --install --wait --timeout 300s
        ### Istio Init Check
        istio_intit_check () {
            ISTIO_CRD=$(kubectl get customresourcedefinitions | grep "gateways.networking.istio.io" ||:)
            COUNTER=0
              while [[ "${COUNTER}" -lt 24 ]]; do
              ISTIO_CRD=$(kubectl get customresourcedefinitions | grep "gateways.networking.istio.io" ||:)
                if [[ -z "${ISTIO_CRD}" ]]; then
                  echo "+++++ Istio resource definition not ready! +++++"
                  COUNTER=$(( COUNTER + 1))
                  sleep 5s
                  continue
                else
                  break
                fi
                done
        }
        ### Run Istio Init Check
        istio_intit_check
        ### Deploy Istio ControlPlane
        helm upgrade istio-cp ego-helm-release/istio-cp -f ${WORKSPACE}/${STACK_NAME}/k8s/util-tier/istio/istio-cp-values.yaml --set-string gateways.istio-ingressgateway.nodeSelector.perf-1-tier=gateway -n istio-system --install --wait --timeout 420s
        ### Apply Istio Routing rules
        kubectl apply -f ${WORKSPACE}/${STACK_NAME}/k8s/util-tier/istio/istio-manifests -n default
      '''
    }}
    stage('Deploy Configuration Manager configmaps') {
      container('microservice-orchestration')  {
      sh '''#!/usr/bin/env bash
        set -eo pipefail
        ### Deploy watch-configmap-role
        kubectl apply -f ${WORKSPACE}/${STACK_NAME}/k8s/microservice-tier/rbac/watch-configmaps-rbac.yaml -n default
        ### Deploy configmaps for Configuration Manager
        kubectl apply -f ${WORKSPACE}/${STACK_NAME}/k8s/microservice-tier/configuration-manager -n default
      '''
    }}
    stage('Deploy Cleanspeak') {
      container('microservice-orchestration')  {
      sh '''#!/usr/bin/env bash
        set -eo pipefail
        ### Get Cleanspeak DB's endpoints
        ES_VPC_ENDPOINT=$(aws es describe-elasticsearch-domain --domain-name ${CLUSTER_NAME}-es-cleanspeak --output json | jq -r '.DomainStatus.Endpoints.vpc')
        RDS_ENDPOINT=$(aws cloudformation describe-stacks --stack-name ${CLUSTER_NAME}-us-west-2-microservice-tier-cleanspeak-rds --output json | jq -r '.Stacks[].Outputs[] | select(.OutputKey == "RDSendpoint") | .OutputValue')
        ### Fetch credentials from Vault ###
        vault_token=$(vault write -address="https://vault.withme.com/" -format=json auth/approle/login role_id=${EGO_VAULT_ROLE_ID} secret_id=${EGO_VAULT_SECRET_ID} | jq .auth.client_token | sed -e 's/^"//' -e 's/"$//')
        vault login -address="https://vault.withme.com/" token=${vault_token} > /dev/null 2>&1
        fetchedSecrets=$(vault kv get -address="https://vault.withme.com/" -format=json cicd/${CLUSTER_NAME}/base64/cleanspeak | jq -r '.data | to_entries | .[] | .key + "=" + .value' | sed "s/^/--set-string secret.secretContents./g" | xargs ||:)
        ### Deploy Cleanspeak
        helm upgrade cleanspeak ego-helm-release/cleanspeak -f ${WORKSPACE}/${STACK_NAME}/k8s/microservice-tier/cleanspeak-values.yaml ${fetchedSecrets} --set-string management.env.DATABASE_URL=jdbc:mysql://${RDS_ENDPOINT}:3306/cleanspeak?useSSL=false --set-string management.env.CLEANSPEAK_SEARCH_SERVERS=https://${ES_VPC_ENDPOINT}:443 --set-string webservice.env.DATABASE_URL=jdbc:mysql://${RDS_ENDPOINT}:3306/cleanspeak?useSSL=false --set-string webservice.env.CLEANSPEAK_SEARCH_SERVERS=https://${ES_VPC_ENDPOINT}:443 -n default --install --wait --timeout 300s
      '''
    }}
    stage('Deploy EGO microservices and tools to cluster') {
      container('microservice-orchestration')  {
      sh '''#!/usr/bin/env bash
        set -eo pipefail
        HELM_VALUES_LIST=helm_values_list.txt
        DB_LIST=db_list.txt
        ### Defining bash functions
        databases_deploy () {
            # Deploy ETCD
            helm upgrade etcd-operator ego-helm-release/etcd-operator -f ${WORKSPACE}/${STACK_NAME}/k8s/database-tier/etcd-operator-values.yaml -n database --install --wait --timeout 420s
            # Deploy MongoDB
            kubectl apply -f ${WORKSPACE}/${STACK_NAME}/k8s/database-tier/mongodb.yaml -n database
            # Readiness check
            kubectl -n database rollout status statefulset/mongodb
        }
        util_deploy () {
            # Deploy service account for Kubernetes Dashboard
            kubectl apply -f ${WORKSPACE}/${STACK_NAME}/k8s/util-tier/eks-admin-service-account.yaml
            # Deploy Kubernetes Dashboard
            kubectl apply -f ${WORKSPACE}/${STACK_NAME}/k8s/util-tier/kubernetes-dashboard.yaml
            # Kubernetes Dashboard Readiness check
            kubectl -n kubernetes-dashboard rollout status deployment/kubernetes-dashboard
            # Deploy Minio
            kubectl apply -f ${WORKSPACE}/${STACK_NAME}/k8s/util-tier/minio.yaml -n default
            # Minio Readiness check
            kubectl -n default rollout status deployment/minio
            # Deploy mock-server
            kubectl apply -f ${WORKSPACE}/${STACK_NAME}/k8s/util-tier/mock-server.yaml -n default
            # Minio Readiness check
            kubectl -n default rollout status deployment/mock-server-deployment
            # Deploy Metric-server
            kubectl apply -f ${WORKSPACE}/${STACK_NAME}/k8s/util-tier/metrics-server/
            # Metric-server Readiness check
            kubectl -n kube-system rollout status deployment/metrics-server
        }
        deploy_ego_microservices () {
          ### Pull EGO Helm charts from Artifactory Helm repo ###
          helm repo add ego-helm-release https://withme.jfrog.io/withme/ego-helm-release/ --username $ART_BUILD_USER --password $ART_BUILD_PASSWORD && helm repo update
          # Create microservices list
          cd ${WORKSPACE}/${STACK_NAME}/k8s
          # Note: "grep ^-" is used to avoid directories names in the microservices list.
          ls -l ${WORKSPACE}/${STACK_NAME}/k8s/microservice-tier -I "*.md" -I "cleanspeak-*" | grep ^- | awk '{ print $9 }' | awk NF > ${WORKSPACE}/${STACK_NAME}/k8s/${HELM_VALUES_LIST}
          # Deploy all EGO microservices.
            while IFS='' read -r line || [[ -n "$line" ]]; do
              APP_NAME=$(echo $line | sed "s/-values.yaml//g")
              helm upgrade ${APP_NAME} ego-helm-release/ego-microservice -f ${WORKSPACE}/${STACK_NAME}/k8s/microservice-tier/${line} -n default --install --wait --timeout 600s
            done < "${HELM_VALUES_LIST}"
        }
        ### Deploy all DBs needed for environment
        databases_deploy
        ### Deploy all Util tools and non-ego-microservices
        util_deploy
        ### Deploy all EGO microservices
        deploy_ego_microservices
      '''
    }}
    stage('Deploy Kube-prometheus-stack') {
      container('microservice-orchestration')  {
      sh '''#!/usr/bin/env bash
        set -eo pipefail
        kubectl apply -f ${WORKSPACE}/${STACK_NAME}/k8s/monitoring-tier/grafana-dashboards -n monitoring
        ### Deploy Kube-prometheus-stack by Helm
        helm upgrade prom-stack ego-helm-release/kube-prometheus-stack -f ${WORKSPACE}/${STACK_NAME}/k8s/monitoring-tier/kube-prometheus-stack-values.yaml --set grafana.adminPassword=$GRAF_PASS -n monitoring --install --wait --timeout 600s
      '''
    }}
    stage('Create Route53 record') {
      container('microservice-orchestration')  {
      sh '''#!/usr/bin/env bash
        set -eo pipefail
        ### Update Route53 by scripts
        echo "Add an alias for the load balancer for the service at ${SUBDOMAIN}"
        ./${STACK_NAME}/update-route53-record-set.sh -n istio-ingressgateway --namespace istio-system -s ${SUBDOMAIN} -a 'UPSERT' || { echo "Error exposing the service at ${SUBDOMAIN}" ; exit 1; }

        echo "Add an alias for the load balancer for the service at cm-${SUBDOMAIN}"
        ./${STACK_NAME}/update-route53-record-set.sh -n istio-ingressgateway --namespace istio-system -s cm-${SUBDOMAIN} -a 'UPSERT' || { echo "Error exposing the service at cm-${SUBDOMAIN}" ; exit 1; }

        echo "Add an alias for the load balancer for the service at cs-${SUBDOMAIN}"
        ./${STACK_NAME}/update-route53-record-set.sh -n istio-ingressgateway --namespace istio-system -s cs-${SUBDOMAIN} -a 'UPSERT' || { echo "Error exposing the service at grafana-${SUBDOMAIN}" ; exit 1; }

        echo "Add an alias for the load balancer for the service at grafana-${SUBDOMAIN}"
        ./${STACK_NAME}/update-route53-record-set.sh -n istio-ingressgateway --namespace istio-system -s grafana-${SUBDOMAIN} -a 'UPSERT' || { echo "Error exposing the service at grafana-${SUBDOMAIN}" ; exit 1; }

        ### Domain resolving function
        dns_check () {
          local domain=$1
          local COUNTER=0
          local ip=""

          while [[ "${COUNTER}" -lt 60 ]]; do
            ip=$(dig +short "${domain}")
              if [[ -n "${ip}" ]]; then
                echo "+++++ Domain '$domain' ip resolved! +++++"
                echo IP: "${ip}"
                return 0
              else
                echo "+++++ Domain $domain still not resolved! +++++"
                COUNTER=$(( COUNTER + 1))
                sleep 10s
              fi
          done

          if [[ -n "${ip}" ]]; then
            echo "+++++ Domain '$domain' ip resolved! +++++"
            echo IP: "${ip}"
            return 0
          else
            echo "Domain name not resolved over 10 minutes!"
            return 1
          fi
        }
        ### Check domain resolving
        dns_check "${SUBDOMAIN}" && dns_check "cm-${SUBDOMAIN}" && dns_check "cs-${SUBDOMAIN}" && dns_check "grafana-${SUBDOMAIN}" && exit 0 || exit 1
      '''
    }}
    stage('Check gRPC port readiness') {
      container('microservice-orchestration')  {
      sh '''#!/usr/bin/env bash
      ### Check 8082 port connectivity
      port_check () {
        local host=$1
        local port=8082
        declare -a ip_list
        ip_list=($(dig "$host" +short))
        # List resolved IP's
        for i in "${ip_list[@]}"; do echo cm-int IP:"$i"; done
      # check while array will be empty
      while [ ${#ip_list[@]} -gt 0 ]; do
        # for loop to check all array vars
        for ip in "${!ip_list[@]}"; do
          local COUNTER=0
          # Use Until for escaping pipeline fail if "nc" throw not "0" exit code
          until nc -v -z -w 10 "${ip_list[${ip}]}" $port; do
            if [[ "${COUNTER}" -lt 17 ]]; then
              COUNTER=$(( COUNTER + 1))
              continue
            else
              echo "+++++ Port $port on ${ip_list[${ip}]} not ready more than 3 minutes! +++++"
               #break loop
              return 1
            fi
          # Until exit
          done
          # If until done with "0" exit code remove IP from array
        if [ $? -eq 0 ]; then
          unset ip_list["${ip}"]
        fi
        # For exit
        done
      # while exit
      done
      }
      ### Check gRPC port readiness
      port_check "cm-${SUBDOMAIN}" || port_check "cm-${SUBDOMAIN}" || exit 1
      '''
    }}
    }}} catch (e) {
        currentBuild.result = 'FAILURE'
        throw e
    } finally {
        notifySlack(currentBuild.result)
        }
}}
