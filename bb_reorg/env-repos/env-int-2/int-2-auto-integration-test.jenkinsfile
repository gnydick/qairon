/* groovylint-disable CompileStatic, CouldBeSwitchStatement, DuplicateStringLiteral, GStringExpressionWithinString, LineLength, MethodReturnTypeRequired, NestedBlockDepth, NoDef, ParameterReassignment, SpaceAfterClosingBrace, SpaceBeforeClosingBrace, VariableTypeRequired */
common = load "lib/common.groovy"



def label = "int-2-automation-${UUID.randomUUID().toString()}"

timestamps {

podTemplate(name: 'int-2-automation', label: label, yaml: """
kind: Pod
metadata:
  name: microservice-orchestration
spec:
  containers:
  - name: microservice-orchestration
    image: 407733091588.dkr.ecr.us-west-2.amazonaws.com/ego-cicd/microservice-orchestration:1.0.15
    imagePullPolicy: Always
    command:
    - /bin/cat
    tty: true
    env:
    - name: STACK_NAME
      value: "env-int-2"
    - name: CLUSTER_NAME
      value: "int-2"
"""
  ) {
node(label) {
  try {
    def secrets = [[$class: 'VaultSecret', path: 'cicd/aws_keys', secretValues: [
                  [$class: 'VaultSecretValue', envVar: 'AWS_ACCESS_KEY_ID', vaultKey: 'AWS_ACCESS_KEY_ID'],
                  [$class: 'VaultSecretValue', envVar: 'AWS_SECRET_ACCESS_KEY', vaultKey: 'AWS_SECRET_ACCESS_KEY']]],
                [$class: 'VaultSecret', path: 'cicd/bitbucket', secretValues: [
                  [$class: 'VaultSecretValue', envVar: 'BITBUCKET_USER', vaultKey: 'BITBUCKET_USER'],
                  [$class: 'VaultSecretValue', envVar: 'BITBUCKET_APP_PASSWORD', vaultKey: 'BITBUCKET_APP_PASSWORD']]],
                [$class: 'VaultSecret', path: 'cicd/artifactory', secretValues: [
                  [$class: 'VaultSecretValue', envVar: 'ART_TOOL_USER', vaultKey: 'ART_TOOL_USER'],
                  [$class: 'VaultSecretValue', envVar: 'ART_TOOL_PASSWORD', vaultKey: 'ART_TOOL_PASSWORD'],
                  [$class: 'VaultSecretValue', envVar: 'ART_BUILD_USER', vaultKey: 'ART_BUILD_USER'],
                  [$class: 'VaultSecretValue', envVar: 'ART_BUILD_PASSWORD', vaultKey: 'ART_BUILD_PASSWORD']]],
                [$class: 'VaultSecret', path: 'cicd/integration/user-manager', secretValues: [
                  [$class: 'VaultSecretValue', envVar: 'GOOGLE_APPLICATION_CREDENTIALS', vaultKey: 'GOOGLE_APPLICATION_CREDENTIALS'],
                  [$class: 'VaultSecretValue', envVar: 'GOOGLE_API_KEY', vaultKey: 'GOOGLE_API_KEY']]]]

    withCredentials([string(credentialsId: 'EGO_VAULT_ROLE_ID', variable: 'EGO_VAULT_ROLE_ID'), string(credentialsId: 'EGO_VAULT_SECRET_ID', variable: 'EGO_VAULT_SECRET_ID')]) {
    echo "${EGO_VAULT_ROLE_ID}"

        wrap([$class: 'VaultBuildWrapper', vaultSecrets: secrets]) {
  properties([
          parameters([string(defaultValue: '', description: 'Tested service name', name: 'APP_NAME', trim: true),
                      string(defaultValue: '', description: 'Tested service version', name: 'APP_VERSION', trim: true),
                      booleanParam(defaultValue: true, description: 'Trigger next pipeline job?', name: 'TRIGGER_NEXT_JOB')]),
          disableConcurrentBuilds()
      ])
    env.APP_NAME = "${params.APP_NAME}"
    env.APP_VERSION = "${params.APP_VERSION}"
    env.JOB_NAME = "${env.JOB_NAME}"
    env.BUILD_NUMBER = "${env.BUILD_NUMBER}"
    currentBuild.displayName = "#${env.BUILD_NUMBER} `${env.APP_NAME}-v${env.APP_VERSION}`"

    stage('Configure aws account and kubectl config') {
      if (env.APP_NAME == '' || env.APP_VERSION == '') {
        return
      } else {
      container('microservice-orchestration')  {
      sh '''#!/usr/bin/env bash
        set -eox pipefail
        /toolbox/set-aws-credentials.sh --key-id ${AWS_ACCESS_KEY_ID} --secret-access-key ${AWS_SECRET_ACCESS_KEY}
        ### Check IAM user
        aws sts get-caller-identity --output text
        ### Configure kubectl
        aws eks --region us-west-2 update-kubeconfig --name ${CLUSTER_NAME}
        ### Check kubectl context
        kubectl config current-context
      '''
    }}}
    stage('Deploy tested microservice') {
      container('microservice-orchestration')  {
      sh '''#!/usr/bin/env bash
        set -eo pipefail
        ### Clone repo environment repository ###
        git clone https://${BITBUCKET_USER}:${BITBUCKET_APP_PASSWORD}@bitbucket.org/imvu/${STACK_NAME}.git

        ### Update image version in "values.yaml" ###
        values_file="${WORKSPACE}/${STACK_NAME}/k8s/microservice-tier/${APP_NAME}-values.yaml"
        sed -i 's/tag: .*/tag: '${APP_VERSION}'/g' ${values_file}

        ### Add "ego-helm-release" Helm repo  ###
        helm repo add ego-helm-release https://withme.jfrog.io/withme/ego-helm-release/ --username $ART_BUILD_USER --password $ART_BUILD_PASSWORD && helm repo update

        ### Fetch credentials from Vault ###
        vault_token=$(vault write -address="https://vault.withme.com/" -format=json auth/approle/login role_id=${EGO_VAULT_ROLE_ID} secret_id=${EGO_VAULT_SECRET_ID} | jq .auth.client_token | sed -e 's/^"//' -e 's/"$//')
        vault login -address="https://vault.withme.com/" token=${vault_token} > /dev/null 2>&1
        fetchedSecrets=$(vault kv get -address="https://vault.withme.com/" -format=json cicd/${CLUSTER_NAME}/base64/${APP_NAME} | jq -r '.data | to_entries | .[] | .key + "=" + .value' | sed "s/^/--set-string secret.secretContents./g" | xargs ||:)

        ### Upgrade microservices with and without secrets in Vault ###
        if [[ -z "${fetchedSecrets}" ]]; then
          helm upgrade ${APP_NAME} ego-helm-release/ego-microservice -f ${values_file} --namespace=default --install --wait --timeout 600s
        else
          helm upgrade ${APP_NAME} ego-helm-release/ego-microservice -f ${values_file} --namespace=default --install --wait --timeout 600s ${fetchedSecrets}
        fi

        ### Additional rollout status check
        kubectl -n default rollout status deployment/${APP_NAME}-deployment
      '''
    }}
    stage('Integration test') {
      container('microservice-orchestration')  {
      if (env.APP_NAME == 'portal-internal-application') {
        echo 'Only deploying "portal-internal-application". Integration test skipped'
      } else {
      sh '''#!/usr/bin/env bash
        set -eo pipefail
        function waitport () {
            local COUNTER=0
            local ip=$1
            local port=$2
            until nc -v -z ${ip} ${port}; do
              if [[ "${COUNTER}" -lt 24 ]]; then
                COUNTER=$(( COUNTER + 1))
                echo "Waiting..."
                sleep 5
                continue
              else
                echo "+++++Port ${port} on ${ip}: not ready more than 2 minutes!+++++"
                #break loop
                return 1
              fi
            done
        }
        function check_http_port_forward () {
            local COUNTER=0
            local port=$1
            until curl -XGET http://localhost:${port}/actuator/prometheus; do
              if [[ "${COUNTER}" -lt 48 ]]; then
                COUNTER=$(( COUNTER + 1))
                echo "Waiting /actuator/prometheus on port ${port}..."
                sleep 5
                continue
              else
                echo "+++++Port Forward for ${port} not ready more than 4 minutes!+++++"
                #break loop
                return 1
              fi
            done
        }
        ### Clone microservice repo
        git clone https://${BITBUCKET_USER}:${BITBUCKET_APP_PASSWORD}@bitbucket.org/imvu/${APP_NAME}.git && cd ${APP_NAME}
        ### Switch to new 'git tag'
        git fetch && git fetch --tags && git checkout ${APP_NAME}-v${APP_VERSION}
        ### Add credentials
        echo -e "\nsystemProp.gradle.wrapperUser=${ART_TOOL_USER}\nsystemProp.gradle.wrapperPassword=${ART_TOOL_PASSWORD}\ndevUser=${ART_BUILD_USER}\ndevPassword=${ART_BUILD_PASSWORD}\npublishUser=build\npublishPassword=" >> ./integration/gradle.properties
        ### Additional port-forward for "account-manager" microservice k8s SVC "rest" and "grpc" ports
        echo "++++++++++++++++++++Additional 'account-manager' port forward enabled++++++++++++++++++++"
        pod_name=$(kubectl -n default get pods -l app=account-manager --sort-by=.metadata.creationTimestamp | grep Running |awk {'print $1'}|tail -1)
        kubectl -n default port-forward --pod-running-timeout=2m0s ${pod_name} 9092:8080 &>/dev/null &
        kubectl -n default port-forward --pod-running-timeout=2m0s ${pod_name} 9093:8081 &>/dev/null &
        ### Additional port-forward for "messenger-server" microservice k8s SVC "grpc" port
        echo "++++++++++++++++++++Additional 'messenger-server' port forward enabled++++++++++++++++++++"
        pod_name=$(kubectl -n default get pods -l app=messenger-server --sort-by=.metadata.creationTimestamp | grep Running |awk {'print $1'}|tail -1)
        kubectl -n default port-forward --pod-running-timeout=2m0s ${pod_name} 9094:8081 &>/dev/null &
        ### Additional port-forward for "leaderboard-server" microservice REST and gRPC port
        pod_name=$(kubectl -n default get pods -l app=leaderboard-server --sort-by=.metadata.creationTimestamp --field-selector=status.phase=Running -o custom-columns=:metadata.name|tail -1)
        [ -z "$pod_name" ] && echo "leaderboard-server pod is not running"
        kubectl -n default port-forward --pod-running-timeout=2m0s ${pod_name} 9095:8080 &>/dev/null &
        kubectl -n default port-forward --pod-running-timeout=2m0s ${pod_name} 9096:8081 &>/dev/null &
        ### Additional port-forward for "possession-manager" microservice gRPC port
        pod_name=$(kubectl -n default get pods -l app=possession-manager --sort-by=.metadata.creationTimestamp --field-selector=status.phase=Running -o custom-columns=:metadata.name|tail -1)
        [ -z "$pod_name" ] && echo "possession-manager pod is not running"
        kubectl -n default port-forward --pod-running-timeout=2m0s ${pod_name} 9097:8081 &>/dev/null &

        ### Start port-forward tested microservice k8s SVC "rest" and "grpc" ports
        echo "++++++++++++++++++++Port forward enabled++++++++++++++++++++"
        pod_name=$(kubectl -n default get pods -l app=${APP_NAME} --sort-by=.metadata.creationTimestamp | grep Running |awk {'print $1'}|tail -1)
        echo "Starting forward for pod $pod_name"
        kubectl -n default port-forward --pod-running-timeout=2m0s ${pod_name} 9090:8080 &
        kubectl -n default port-forward --pod-running-timeout=2m0s ${pod_name} 9091:8081 &
        # Call waitport function to check forwarded port.
        waitport 127.0.0.1 9090
        # Test forwarded REST port by curl request.
        check_http_port_forward 9090
        echo "++++++++++++++++++++Port forward works!++++++++++++++++++++"
        ### Run integration test
        cd ./integration && ./gradlew clean build -PtestEnv=${CLUSTER_NAME} --info
        ### Kill all background (port-forward) jobs
        jobs -p | xargs kill ||:
      '''
    }}}
    stage('Push tested version to env-int-2') {
      container('microservice-orchestration')  {
      sh '''#!/usr/bin/env bash
        set -eo pipefail
        cd ${STACK_NAME} && git checkout master
        git config --global user.name "jenkins"
        git config --global user.email "jenkins@imvu.com"
        git diff-index --quiet HEAD || git commit -am "Up ${APP_NAME} image version to ${APP_VERSION}. ${JOB_NAME}:#${BUILD_NUMBER}"
        # Added loop in case if developers push changes to "env-int-2" repo while pipeline running.
        COUNTER=0
        until git push origin master
        do
          if [[ "${COUNTER}" -eq '120' ]]; then
            echo "Can't push to master branch. Something wrong with Bitbucket or with repository"
            exit 1
          else
            sleep 1s
            COUNTER=$(( COUNTER + 1))
            echo "Pull and try again"
            git pull
          fi
        done
      '''
    }}}}
      stage('Trigger prod-1 pipeline') {
        if (params.TRIGGER_NEXT_JOB.toBoolean()) {
          build job: 'prod-1-auto-integration-test', wait: false, parameters: [string(name: 'APP_NAME', value:"${APP_NAME}"),
                                                                    string(name: 'APP_VERSION', value: "${APP_VERSION}")]
          } else {
            print 'prod-1 pipeline not triggered'
    }}
    } catch (e) {
        currentBuild.result = 'FAILURE'
        throw e
    } finally {
      stage('Send notifications') {
        container('microservice-orchestration')  {
        if (env.APP_NAME == '' || env.APP_VERSION == '') {
          currentBuild.result = 'ABORTED'
          common.notifySlack(currentBuild.result, '#jnkns_int_tests')
          return
        } else {
            common.notifySlack(currentBuild.result, '#jnkns_int_tests')
        }
        if (currentBuild.result == 'FAILURE') {
            common.notifySlack(currentBuild.result, '#jnkns_int_tests', '#FF9FA1', "${currentBuild.result}`${env.JOB_NAME}` ${env.BUILD_DISPLAY_NAME}\nRunning 'Rollback for ${env.APP_NAME} from v${env.APP_VERSION} version to previous' stage.")
            sh '''#!/usr/bin/env bash
              helm rollback "${APP_NAME}" --namespace=default
            '''
        } else {
        return
        }}}}
}}

} // End timestamps
