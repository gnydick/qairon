/* groovylint-disable CompileStatic, CouldBeSwitchStatement, DuplicateStringLiteral, GStringExpressionWithinString, LineLength, MethodReturnTypeRequired, NestedBlockDepth, NoDef, ParameterReassignment, SpaceAfterClosingBrace, SpaceBeforeClosingBrace, VariableTypeRequired */
def notifySlack(String buildStatus = 'STARTED') {

    // Build status of null means success.
    buildStatus = buildStatus ?: 'SUCCESS'
    def icons
    if (buildStatus == 'STARTED') {
        icons = ':biking:'
    } else if (buildStatus == 'SUCCESS') {
        icons = ':pusheen_dancing:'
    } else if (buildStatus == 'ABORTED') {
        icons = ':thinking_face:'
    } else {
        icons = ':twitching:'
    }
    def color
    if (buildStatus == 'STARTED') {
        color = '#D4DADF'
    } else if (buildStatus == 'SUCCESS') {
        color = '#BDFFC3'
    } else if (buildStatus == 'ABORTED') {
        color = '#FFFE89'
    } else {
        color = '#FF9FA1'
    }
    def msg = "${buildStatus}${icons}: `${env.JOB_NAME}` ${env.BUILD_DISPLAY_NAME}:\n<${env.BUILD_URL}console|Watch build console output>"
    slackSend(color: color, message: msg)
}

def label = "int-1-automation-${UUID.randomUUID().toString()}"

podTemplate(name: 'int-1-automation', label: label, yaml: """
kind: Pod
metadata:
  name: microservice-orchestration
spec:
  containers:
  - name: microservice-orchestration
    image: 407733091588.dkr.ecr.us-west-2.amazonaws.com/ego-cicd/microservice-orchestration:1.0.9
    imagePullPolicy: Always
    command:
    - /bin/cat
    tty: true
    env:
    - name: AWS_REGION
      value: "us-west-2"
    - name: STACK_NAME
      value: "env-int-1"
    - name: CLUSTER_NAME
      value: "int-1"
    - name: SUBDOMAIN
      value: "int-1.withme.com"
    - name: NODE_QUANTITY
      value: "6"
"""
  ) {
node(label) {
  try {
  def secrets = [[$class: 'VaultSecret', path: 'cicd/aws_keys', secretValues: [
                  [$class: 'VaultSecretValue', envVar: 'AWS_ACCESS_KEY_ID', vaultKey: 'AWS_ACCESS_KEY_ID'],
                  [$class: 'VaultSecretValue', envVar: 'AWS_SECRET_ACCESS_KEY', vaultKey: 'AWS_SECRET_ACCESS_KEY']]],
                [$class: 'VaultSecret', path: 'cicd/bitbucket', secretValues: [
                  [$class: 'VaultSecretValue', envVar: 'BITBUCKET_USER', vaultKey: 'BITBUCKET_USER'],
                  [$class: 'VaultSecretValue', envVar: 'BITBUCKET_APP_PASSWORD', vaultKey: 'BITBUCKET_APP_PASSWORD']]],
                [$class: 'VaultSecret', path: 'cicd/datadog', secretValues: [
                  [$class: 'VaultSecretValue', envVar: 'DD_API_KEY', vaultKey: 'API_KEY']]],
                [$class: 'VaultSecret', path: 'cicd/artifactory', secretValues: [
                  [$class: 'VaultSecretValue', envVar: 'ART_TOOL_USER', vaultKey: 'ART_TOOL_USER'],
                  [$class: 'VaultSecretValue', envVar: 'ART_TOOL_PASSWORD', vaultKey: 'ART_TOOL_PASSWORD'],
                  [$class: 'VaultSecretValue', envVar: 'ART_BUILD_USER', vaultKey: 'ART_BUILD_USER'],
                  [$class: 'VaultSecretValue', envVar: 'ART_BUILD_PASSWORD', vaultKey: 'ART_BUILD_PASSWORD']]]]
      wrap([$class: 'VaultBuildWrapper', vaultSecrets: secrets]) {
  properties([
          disableConcurrentBuilds()
      ])
    env.JOB_NAME = "${env.JOB_NAME}"
    env.BUILD_NUMBER = "${env.BUILD_NUMBER}"

    stage('Configure aws account') {
      notifySlack()
      container('microservice-orchestration')  {
      sh '''#!/usr/bin/env bash
        set -eox pipefail
        /toolbox/set-aws-credentials.sh --key-id ${AWS_ACCESS_KEY_ID} --secret-access-key ${AWS_SECRET_ACCESS_KEY}
        ### Check IAM user
        aws sts get-caller-identity --output text
      '''
    }}
    stage('Environment initiation') {
      container('microservice-orchestration')  {
      sh '''#!/usr/bin/env bash
        set -eo pipefail
        ### Clone repo
        git clone https://${BITBUCKET_USER}:${BITBUCKET_APP_PASSWORD}@bitbucket.org/imvu/${STACK_NAME}.git && cd ${STACK_NAME}/aws

        ### Create environment
        sceptre launch ${AWS_REGION} -y

        ### Configure kubectl
        aws eks --region us-west-2 update-kubeconfig --name ${CLUSTER_NAME}

        ### Check EKS k8s service readiness
        COUNTER=0
        while [[ "${COUNTER}" -lt 30 ]]; do
        EKS_READINESS=$(kubectl get svc -n default | grep 'kubernetes')
            if [[ -z "${EKS_READINESS}" ]]; then
              echo "+++++ EKS masters not ready! +++++"
              COUNTER=$(( COUNTER + 1))
              sleep 10s
              continue
            else
              break
            fi
        done
        if [[ -z "${EKS_READINESS}" ]]; then
          echo  "+++++ EKS masters is not ready more than five minutes! +++++"
          exit 1
        else
          echo  "+++++ EKS masters ready for join worker nodes! +++++"
        fi

        ### Checking that worker nodes added to a cluster
        NODE_COUNT=$(kubectl get nodes | grep -c 'compute.internal' ||:)
        COUNTER=0
        while [[ "${NODE_COUNT}" != "${NODE_QUANTITY}" ]]; do
          NODE_COUNT=$(kubectl get nodes | grep -c 'compute.internal' ||:)
          echo -n "${NODE_COUNT}"
          sleep 10s
          COUNTER=$(( COUNTER + 1))
          if [[ "${COUNTER}" -eq '30' ]]; then
            echo "+++++ Workers is not ready more than five minutes! +++++"
            exit 1
          fi
        done

        echo "The nodes started.  Waiting for all ${NODE_COUNT} to be ready to receive a deployment."
        READY_COUNT=$(kubectl get nodes | grep -c 'Ready')
        COUNTER=0
        while [[ "${READY_COUNT}" != "${NODE_COUNT}" ]]; do
          READY_COUNT=$(kubectl get nodes | grep -c 'Ready')
          echo -n "${READY_COUNT}"
          sleep 20s
          COUNTER=$(( COUNTER + 1))
          if [[ "${COUNTER}" -eq '30' ]]; then
            echo "+++++ Workers is not ready more than ten minutes! +++++"
            exit 1
          fi
        done
        echo "All nodes started and ready for work!"
      '''
    }}
    stage('Deploy logging tools') {
      container('microservice-orchestration')  {
      sh '''#!/usr/bin/env bash
        set -eo pipefail
        ### Create namespace and Helm install
        kubectl create namespace database
        kubectl create namespace datadog
        helm repo add ego-helm-release https://withme.jfrog.io/withme/ego-helm-release/ --username $ART_BUILD_USER --password $ART_BUILD_PASSWORD && helm repo update
        helm repo add datadog https://helm.datadoghq.com && helm repo add stable https://charts.helm.sh/stable && helm repo update
      '''
    }}
    stage('Deploy Redis') {
      container('microservice-orchestration')  {
      sh '''#!/usr/bin/env bash
        set -eo pipefail
        ### Create namespace and Helm install
        helm install --namespace=database -f ${WORKSPACE}/${STACK_NAME}/k8s/databases/redis/redis-values.yaml --atomic --timeout 600s --name-template=redis ego-helm-release/redis
      '''
    }}
    stage('Deploy NginX Ingress Controller') {
      container('microservice-orchestration')  {
      sh '''#!/usr/bin/env bash
        set -eo pipefail
        ### Deploy NginX
        kubectl apply -f ./${STACK_NAME}/k8s/service-gateway/nginx-ingress.yaml || { echo "Error deploying the NGiNX Ingress Controller" ; exit 1; }
      '''
    }}
    stage('Deploy DataDog Agent') {
      container('microservice-orchestration')  {
      sh '''#!/usr/bin/env bash
        set -eo pipefail
        ### Deploy DataDog Agent
        helm install datadog-agent datadog/datadog -f ${WORKSPACE}/${STACK_NAME}/k8s/monitoring/datadog-agent-values.yaml -n datadog --set datadog.site='datadoghq.com' --set datadog.apiKey=${DD_API_KEY}
      '''
    }}
    stage('Deploy EGO microservices and tools to cluster') {
      container('microservice-orchestration')  {
      sh '''#!/usr/bin/env bash
        set -eo pipefail
        HELM_VALUES_LIST=helm_values_list.txt
        DB_LIST=db_list.txt
        ### Defining bash functions
        databases_deploy () {
            kubectl apply -f ${WORKSPACE}/${STACK_NAME}/k8s/databases/etcd-operator-cluster.yaml -n default
            ETCD_READINESS=$(kubectl get customresourcedefinitions | grep "etcdclusters.etcd.database.coreos.com" ||:)
            COUNTER=0
              while [[ "${COUNTER}" -lt 24 ]]; do
              ETCD_READINESS=$(kubectl get customresourcedefinitions | grep "etcdclusters.etcd.database.coreos.com" ||:)
                if [[ -z "${ETCD_READINESS}" ]]; then
                  echo "+++++ ETCD resource definition not ready! +++++"
                  COUNTER=$(( COUNTER + 1))
                  sleep 5s
                  continue
                else
                  break
                fi
                done
            # Deploy ETCD cluster
            kubectl apply -f ${WORKSPACE}/${STACK_NAME}/k8s/databases/etcd-cluster.yaml -n default
            # Deploy MongoDB
            kubectl apply -f ${WORKSPACE}/${STACK_NAME}/k8s/databases/mongodb.yaml -n database
            # Readiness check
            kubectl -n database rollout status statefulset/mongodb
        }
        util_deploy () {
            # Deploy service account for Kubernetes Dashboard
            kubectl apply -f ${WORKSPACE}/${STACK_NAME}/k8s/util/eks-admin-service-account.yaml
            # Deploy Kubernetes Dashboard
            kubectl apply -f ${WORKSPACE}/${STACK_NAME}/k8s/util/kubernetes-dashboard.yaml
            # Kubernetes Dashboard Readiness check
            kubectl -n kubernetes-dashboard rollout status deployment/kubernetes-dashboard
            # Deploy Minio
            kubectl apply -f ${WORKSPACE}/${STACK_NAME}/k8s/util/minio.yaml -n default
            # Minio Readiness check
            kubectl -n default rollout status deployment/minio
            # Deploy mock-server
            kubectl apply -f ${WORKSPACE}/${STACK_NAME}/k8s/util/mock-server.yaml -n default
            # Minio Readiness check
            kubectl -n default rollout status deployment/mock-server-deployment
            # Deploy Metric-server
            kubectl apply -f ${WORKSPACE}/${STACK_NAME}/k8s/util/metrics-server/
            # Metric-server Readiness check
            kubectl -n kube-system rollout status deployment/metrics-server
        }
        service_gateway_deploy () {
            # Deploy service-gateway
            kubectl -n default apply -f ${WORKSPACE}/${STACK_NAME}/k8s/service-gateway/service-gateway.yaml
            # service-gateway Readiness check
            kubectl -n default rollout status deployment/service-gateway-deployment
        }
        deploy_ego_microservices () {
          ### Pull EGO Helm charts from Artifactory Helm repo ###
          helm repo add ego-helm-release https://withme.jfrog.io/withme/ego-helm-release/ --username $ART_BUILD_USER --password $ART_BUILD_PASSWORD && helm repo update
          #Create microservices list
          cd ${WORKSPACE}/${STACK_NAME}/k8s
          ls -l ${WORKSPACE}/${STACK_NAME}/k8s/microservices | awk '{ print $9 }' | awk NF > ${WORKSPACE}/${STACK_NAME}/k8s/${HELM_VALUES_LIST}
          # Deploy all EGO microservices.
            while IFS='' read -r line || [[ -n "$line" ]]; do
              APP_NAME=$(echo $line | sed "s/-values.yaml//g")
              helm upgrade ${APP_NAME} ego-helm-release/ego-microservice --version 1.0.6 -f ${WORKSPACE}/${STACK_NAME}/k8s/microservices/${line} --namespace=default --install --wait --timeout 600s
            done < "${HELM_VALUES_LIST}"
        }
        ### Deploy all DBs needed for environment
        databases_deploy
        ### Deploy service-gateway
        service_gateway_deploy
        ### Deploy all Util tools and non-ego-microservices
        util_deploy
        ### Deploy all EGO microservices
        deploy_ego_microservices
      '''
    }}
    stage('Create Route53 record') {
      container('microservice-orchestration')  {
      sh '''#!/usr/bin/env bash
        set -eo pipefail
        ### Update Route53 by scripts
        echo "Add an alias for the load balancer for the service at ${SUBDOMAIN}"
        ./${STACK_NAME}/update-route53-record-set.sh -n ingress-nginx --namespace ingress-nginx -s ${SUBDOMAIN} -a 'UPSERT' || { echo "Error exposing the service at ${SUBDOMAIN}" ; exit 1; }

        echo "Add an alias for the load balancer for the service at cm-${SUBDOMAIN}"
        ./${STACK_NAME}/update-route53-record-set.sh -n service-gateway-grpc-load-balancer -s cm-${SUBDOMAIN} -a 'UPSERT' || { echo "Error exposing the service at cm-${SUBDOMAIN}" ; exit 1; }

        ### Domain resolving function
        dns_check () {
          local domain=$1
          local COUNTER=0
          local ip=""

          while [[ "${COUNTER}" -lt 60 ]]; do
            ip=$(dig +short "${domain}")
              if [[ -n "${ip}" ]]; then
                echo "+++++ Domain '$domain' ip resolved! +++++"
                echo IP: "${ip}"
                return 0
              else
                echo "+++++ Domain $domain still not resolved! +++++"
                COUNTER=$(( COUNTER + 1))
                sleep 10s
              fi
          done

          if [[ -n "${ip}" ]]; then
            echo "+++++ Domain '$domain' ip resolved! +++++"
            echo IP: "${ip}"
            return 0
          else
            echo "Domain name not resolved over 10 minutes!"
            return 1
          fi
        }
        ### Check domain resolving
        dns_check "${SUBDOMAIN}" && dns_check "cm-${SUBDOMAIN}" && exit 0 || exit 1
      '''
    }}
    stage('Check gRPC port readiness') {
      container('microservice-orchestration')  {
      sh '''#!/usr/bin/env bash
      ### Check 8082 port connectivity
      port_check () {
        local host=$1
        local port=8082
        declare -a ip_list
        ip_list=($(dig "$host" +short))
        # List resolved IP's
        for i in "${ip_list[@]}"; do echo cm-int IP:"$i"; done
      # check while array will be empty
      while [ ${#ip_list[@]} -gt 0 ]; do
        # for loop to check all array vars
        for ip in "${!ip_list[@]}"; do
          local COUNTER=0
          # Use Until for escaping pipeline fail if "nc" throw not "0" exit code
          until nc -v -z -w 10 "${ip_list[${ip}]}" $port; do
            if [[ "${COUNTER}" -lt 17 ]]; then
              COUNTER=$(( COUNTER + 1))
              continue
            else
              echo "+++++ Port $port on ${ip_list[${ip}]} not ready more than 3 minutes! +++++"
               #break loop
              return 1
            fi
          # Until exit
          done
          # If until done with "0" exit code remove IP from array
        if [ $? -eq 0 ]; then
          unset ip_list["${ip}"]
        fi
        # For exit
        done
      # while exit
      done
      }
      ### Check gRPC port readiness
      port_check "cm-${SUBDOMAIN}" || port_check "cm-${SUBDOMAIN}" || exit 1
      '''
    }}
    }} catch (e) {
        currentBuild.result = 'FAILURE'
        throw e
    } finally {
        notifySlack(currentBuild.result)
        }
}}
